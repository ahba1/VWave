#pragma once
#include <iostream>
#include <jvmti.h>

namespace VMModel {
/***********************************Access Flag(method class)***************************************/

    typedef jint AccessFlag;

    const AccessFlag ACC_PUBLIC = 1;
    const AccessFlag ACC_PRIVATE = 1 << 1;
    const AccessFlag ACC_PROTECTED = 1 << 3;
    const AccessFlag ACC_FINAL = 1 << 4;
    const AccessFlag ACC_SYNCHRONIZED = 1 << 5;
    const AccessFlag ACC_BRIDGE = 1 << 6; //a bridge method that generated by compiler
    const AccessFlag ACC_VARARGS = 1 << 7; //declared with a variable number of argument
    const AccessFlag ACC_NATIVE = 1 << 8;
    const AccessFlag ACC_ABSTRACT = 1 << 9;
    const AccessFlag ACC_STRICT = 1 << 10;
    const AccessFlag ACC_SYNTHETIC = 1 << 11; //declare syntheic; not present in the source code

    bool ContainAccessFlag(AccessFlag source_flag, AccessFlag target);

/***********************************Thread State****************************************************/

    typedef jint ThreadState;

    const ThreadState NOT_ALIVE = 0;
    const ThreadState ALIVE = 1;
    const ThreadState TERMINATED = 1 << 1;
    const ThreadState RUNNABLE = 1 << 2;
    const ThreadState BLOCKED_ON_MONITOR_ENTER = 1 << 10;
    const ThreadState WAITING = 1 << 7;
    const ThreadState WAITING_INDEFINITELY = 1 << 4;
    const ThreadState WAITING_WITH_TIMEOUT = 1 << 5;
    const ThreadState SLEEPING = 1 << 6;
    const ThreadState IN_OBJECT_WAIT = 1 << 8;
    const ThreadState PARKED = 1 << 9;
    const ThreadState SUSPENDED = 1 << 20;
    const ThreadState INTERRUPTED = 1 << 21; 
    const ThreadState IN_NATIVE = 1 << 22;

    class Clazz {
    public:
        jclass _klazz;
        char *name;
        char *signature;
        char *generic;
        AccessFlag access_flag;
        jboolean isInterface;
    };

    class Method {
    public:
        Clazz *clazz;
        jmethodID _methodID;
        char *name;        
        char *generic;
        char *signature;
        AccessFlag access_flag;
        int param_len;
        jboolean isNative;
    };

    void MapJMethod(jvmtiEnv *env, jmethodID methodID, Method *method);
    void DeallocateMethod(jvmtiEnv *env, Method *method);
    void MapJClazz(jvmtiEnv *env, jclass klazz, Clazz *clazz);

/*****************************************thread*************************************/
    typedef char* (*Format)(char*, int, int, bool); //name, state, priority, isDaemon
    char* DefaultFormat(char* name, int state, int priority, bool isDaemon) {
        return NULL;
    }
    //using JVMThread to differ from Thread
    class JVMThread {
    
    public:
        jthread _thread;
        jvmtiThreadInfo *info;
        ThreadState state;

        void Println(Format *func, std::streambuf *target = std::cout.rdbuf());
    };

    void MapJThread(jvmtiEnv *env, jthread _jthread, JVMThread *thread);
    void DeallocateThread(jvmtiEnv *env, JVMThread *thread);
}