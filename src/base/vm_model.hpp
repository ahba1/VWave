#pragma once
#include <iostream>
#include <regex>
#include <jvmti.h>

#include "../vm_service_manager.hpp"

namespace VMModel {

    typedef jint AccessFlag;
    typedef jint ThreadState;

    const AccessFlag ACC_PUBLIC = 1;
    const AccessFlag ACC_PRIVATE = 1 << 1;
    const AccessFlag ACC_PROTECTED = 1 << 3;
    const AccessFlag ACC_FINAL = 1 << 4;
    const AccessFlag ACC_SYNCHRONIZED = 1 << 5;
    const AccessFlag ACC_BRIDGE = 1 << 6; //a bridge method that generated by compiler
    const AccessFlag ACC_VARARGS = 1 << 7; //declared with a variable number of argument
    const AccessFlag ACC_NATIVE = 1 << 8;
    const AccessFlag ACC_ABSTRACT = 1 << 9;
    const AccessFlag ACC_STRICT = 1 << 10;
    const AccessFlag ACC_SYNTHETIC = 1 << 11; //declare syntheic; not present in the source code

    char* GetAccessFlag(AccessFlag flag) {
        switch (flag)
        {
        case ACC_PUBLIC:
            return "public";        
        case ACC_PRIVATE:
            return "private";
        case ACC_PROTECTED:
            return "protected";
        case ACC_FINAL:
            return "final";
        case ACC_SYNCHRONIZED:
            return "synchronized";
        case ACC_NATIVE:
            return "native";
        case ACC_ABSTRACT:
            return "abstract";
            default: return NULL;
        }
    }

    bool ContainAccessFlag(AccessFlag source_flag, AccessFlag target) {
        return source_flag & target;
    }

    class Clazz {

    public:
        jclass _klazz;
        char *name;
        char *signature;
        char *generic;
        AccessFlag access_flag;
        jboolean isInterface;
    };

    class Method {

    private:

    public:
        Clazz *clazz;
        jmethodID _methodID;
        char *name;        
        char *generic;
        char *signature;
        AccessFlag access_flag;
        int param_len;
        jboolean isNative;

        void Println(std::regex r, std::streambuf *target = std::cout.rdbuf()) {
            std::cout.rdbuf(target); //redirect the target stream
            char *access;
            if (ContainAccessFlag(access_flag, ACC_PUBLIC)) {
                access = GetAccessFlag(ACC_PUBLIC);
            } else if (ContainAccessFlag(access_flag, ACC_PRIVATE)) {
                access = GetAccessFlag(ACC_PRIVATE);
            } else if (ContainAccessFlag(access_flag, ACC_PROTECTED)) {
                access = GetAccessFlag(ACC_PROTECTED);
            }
            std::cout<<access<<" ";
            if (isNative) {
                std::cout<<GetAccessFlag(ACC_NATIVE)<<" ";
            }
            if (ContainAccessFlag(access_flag, ACC_FINAL)) {
                std::cout<<GetAccessFlag(ACC_FINAL)<<" ";
            } else if (ContainAccessFlag(access_flag, ACC_ABSTRACT)) {
                std::cout<<GetAccessFlag(ACC_ABSTRACT)<<" ";
            }
            if (ContainAccessFlag(access_flag, ACC_SYNCHRONIZED)) {
                std::cout<<GetAccessFlag(ACC_SYNCHRONIZED)<<" ";
            }
            std::cout<<signature<<" "<<name<<std::endl;
            std::cout.flush();
        }
    };

    void MapJMethod(jvmtiEnv *env, jmethodID methodID, Method *method) {
        jvmtiError error;
        method->_methodID = methodID;
        error = env->GetMethodName(methodID, &method->name, &method->signature, &method->generic);
        VWaveService::CheckException(error);
        error = env->GetMethodModifiers(methodID, &method->access_flag);
        VWaveService::CheckException(error);
        error = env->IsMethodNative(methodID, &method->isNative);
        VWaveService::CheckException(error);
        Clazz *clazz = new Clazz();
        error = env->GetMethodDeclaringClass(methodID, &clazz->_klazz);
        VWaveService::CheckException(error);
        MapJClazz(env, clazz->_klazz, clazz);
    }

    void MapJClazz(jvmtiEnv *env, jclass klazz, Clazz *clazz) {
        jvmtiError error;
        clazz->_klazz = klazz;
        error = env->GetClassSignature(klazz, &clazz->signature, &clazz->generic);
        VWaveService::CheckException(error);
        error = env->GetSourceFileName(klazz, &clazz->name);
        VWaveService::CheckException(error);
        error = env->GetClassModifiers(klazz, &clazz->access_flag);
        VWaveService::CheckException(error);
        error = env->IsInterface(klazz, &clazz->isInterface);
        VWaveService::CheckException(error);
    }

    void DeallocateMethod(jvmtiEnv *env, Method *method) {
        env->Deallocate(reinterpret_cast<unsigned char*>(method->name));
        env->Deallocate(reinterpret_cast<unsigned char*>(method->generic));
        env->Deallocate(reinterpret_cast<unsigned char*>(method->signature));
        env->Deallocate(reinterpret_cast<unsigned char*>(method));
    }

    
 /*--------------------------------------------Thread---------------------------------------------------*/
    typedef char* (*Format)(char*, int, int, bool); //name, state, priority, isDaemon
    
    //using JVMThread to differ from Thread
    class JVMThread {
    
    public:
        jthread _thread;
        jvmtiThreadInfo *info;
        ThreadState state;

        void Println(Format *func, std::streambuf *target = std::cout.rdbuf()) {
            char *output = (*func)(info->name, state, info->priority, info->is_daemon);
            std::cout.rdbuf(target);
            std::cout<<output<<std::endl;
            std::cout.flush();
        }
    };

    char* DefaultFormat(char* name, int state, int priority, bool isDaemon) {
        return NULL;
    }

    void MapJThread(jvmtiEnv *env, jthread _jthread, JVMThread *thread) {
        jvmtiError error;
        thread->_thread = _jthread;
        error = env->GetThreadInfo(_jthread, thread->info);
        VWaveService::CheckException(error);
        error = env->GetThreadState(_jthread, &thread->state);
        VWaveService::CheckException(error);
    }

    void DeallocateThread(jvmtiEnv *env, JVMThread *thread) {
        env->Deallocate(reinterpret_cast<unsigned char*>(thread->_thread));
        env->Deallocate(reinterpret_cast<unsigned char*>(thread->info));
        env->Deallocate(reinterpret_cast<unsigned char*>(thread));
    }

    const ThreadState NOT_ALIVE = 0;
    const ThreadState ALIVE = 1;
    const ThreadState TERMINATED = 1 << 1;
    const ThreadState RUNNABLE = 1 << 2;
    const ThreadState BLOCKED_ON_MONITOR_ENTER = 1 << 10;
    const ThreadState WAITING = 1 << 7;
    const ThreadState WAITING_INDEFINITELY = 1 << 4;
    const ThreadState WAITING_WITH_TIMEOUT = 1 << 5;
    const ThreadState SLEEPING = 1 << 6;
    const ThreadState IN_OBJECT_WAIT = 1 << 8;
    const ThreadState PARKED = 1 << 9;
    const ThreadState SUSPENDED = 1 << 20;
    const ThreadState INTERRUPTED = 1 << 21; 
    const ThreadState IN_NATIVE = 1 << 22;
}