#include <iostream>
#include <regex>
#include <jvmti.h>
#include "vm_service_manager.hpp"

namespace VMModel {

    typedef jint ACCESS_FLAG;

    class Clazz {

    public:
        jclass _klazz;
        char *name;
        char *signature;
        char *generic;
        ACCESS_FLAG access_flag;
        jboolean isInterface;
    };

    class Method {

    private:

    public:
        Clazz *clazz;
        jmethodID _methodID;
        char *name;        
        char *generic;
        char *signature;
        ACCESS_FLAG access_flag;
        int param_len;
        jboolean isNative;

        void Println(std::regex r, std::streambuf *target = std::cout.rdbuf()) {
            std::cout.rdbuf(target); //redirect the target stream
            char *access;
            if (ContainAccessFlag(access_flag, ACC_PUBLIC)) {
                access = GetAccessFlag(ACC_PUBLIC);
            } else if (ContainAccessFlag(access_flag, ACC_PRIVATE)) {
                access = GetAccessFlag(ACC_PRIVATE);
            } else if (ContainAccessFlag(access_flag, ACC_PROTECTED)) {
                access = GetAccessFlag(ACC_PROTECTED);
            }
            std::cout<<access<<" ";
            if (isNative) {
                std::cout<<GetAccessFlag(ACC_NATIVE)<<" ";
            }
            if (ContainAccessFlag(access_flag, ACC_FINAL)) {
                std::cout<<GetAccessFlag(ACC_FINAL)<<" ";
            } else if (ContainAccessFlag(access_flag, ACC_ABSTRACT)) {
                std::cout<<GetAccessFlag(ACC_ABSTRACT)<<" ";
            }
            if (ContainAccessFlag(access_flag, ACC_SYNCHRONIZED)) {
                std::cout<<GetAccessFlag(ACC_SYNCHRONIZED)<<" ";
            }
            std::cout<<signature<<" "<<name<<std::endl;
            std::cout.flush();
        }
    };

    char* GetAccessFlag(ACCESS_FLAG flag) {
        switch (flag)
        {
        case ACC_PUBLIC:
            return "public";        
        case ACC_PRIVATE:
            return "private";
        case ACC_PROTECTED:
            return "protected";
        case ACC_FINAL:
            return "final";
        case ACC_SYNCHRONIZED:
            return "synchronized";
        case ACC_NATIVE:
            return "native";
        case ACC_ABSTRACT:
            return "abstract";
            default: return NULL;
        }
    }

    bool ContainAccessFlag(ACCESS_FLAG source_flag, ACCESS_FLAG target) {
        return source_flag & target;
    }

    void MapJMethod(jvmtiEnv *env, jmethodID methodID, Method *method) {
        jvmtiError error;
        method->_methodID = methodID;
        error = env->GetMethodName(methodID, &method->name, &method->signature, &method->generic);
        VWaveService::CheckException(error);
        error = env->GetMethodModifiers(methodID, &method->access_flag);
        VWaveService::CheckException(error);
        error = env->IsMethodNative(methodID, &method->isNative);
        VWaveService::CheckException(error);
        Clazz *clazz = new Clazz();
        error = env->GetMethodDeclaringClass(methodID, &clazz->_klazz);
        VWaveService::CheckException(error);
        MapJClazz(env, clazz->_klazz, clazz);
    }

    void MapJClazz(jvmtiEnv *env, jclass klazz, Clazz *clazz) {
        jvmtiError error;
        clazz->_klazz = klazz;
        error = env->GetClassSignature(klazz, &clazz->signature, &clazz->generic);
        VWaveService::CheckException(error);
        error = env->GetSourceFileName(klazz, &clazz->name);
        VWaveService::CheckException(error);
        error = env->GetClassModifiers(klazz, &clazz->access_flag);
        VWaveService::CheckException(error);
        error = env->IsInterface(klazz, &clazz->isInterface);
        VWaveService::CheckException(error);
    }

    void DeallocateMethod(jvmtiEnv *env, Method *method) {
        env->Deallocate(reinterpret_cast<unsigned char*>(method->name));
        env->Deallocate(reinterpret_cast<unsigned char*>(method->generic));
        env->Deallocate(reinterpret_cast<unsigned char*>(method->signature));
        env->Deallocate(reinterpret_cast<unsigned char*>(method));
    }

    const ACCESS_FLAG ACC_PUBLIC = 1;
    const ACCESS_FLAG ACC_PRIVATE = 1 << 1;
    const ACCESS_FLAG ACC_PROTECTED = 1 << 3;
    const ACCESS_FLAG ACC_FINAL = 1 << 4;
    const ACCESS_FLAG ACC_SYNCHRONIZED = 1 << 5;
    const ACCESS_FLAG ACC_BRIDGE = 1 << 6; //a bridge method that generated by compiler
    const ACCESS_FLAG ACC_VARARGS = 1 << 7; //declared with a variable number of argument
    const ACCESS_FLAG ACC_NATIVE = 1 << 8;
    const ACCESS_FLAG ACC_ABSTRACT = 1 << 9;
    const ACCESS_FLAG ACC_STRICT = 1 << 10;
    const ACCESS_FLAG ACC_SYNTHETIC = 1 << 11; //declare syntheic; not present in the source code
}