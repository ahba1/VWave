#include <jvmti.h>
#include "vm_service_manager.hpp"

namespace VMModel {

    typedef jint ACCESS_FLAG;

    class Clazz {

    public:
        jclass _klazz;
        char* name;
        char* signature;
        char* generic;
        ACCESS_FLAG access_flag;
        jboolean isInterface;
    };

    class Method {

    private:

    public:
        Clazz *clazz;
        jmethodID _methodID;
        char* name;        
        char* generic;
        char* signature;
        ACCESS_FLAG access_flag;
        int param_len;
        jboolean isNative;
    };

    bool ContainAccessFlag(ACCESS_FLAG source_flag, ACCESS_FLAG target) {
        return source_flag & target;
    }

    void MapJMethod(jvmtiEnv *env, jmethodID methodID, Method *method) {
        jvmtiError error;
        method->_methodID = methodID;
        error = env->GetMethodName(methodID, &method->name, &method->signature, &method->generic);
        VWaveService::CheckException(error);
        error = env->GetMethodModifiers(methodID, &method->access_flag);
        VWaveService::CheckException(error);
        error = env->IsMethodNative(methodID, &method->isNative);
        VWaveService::CheckException(error);
        Clazz *clazz = new Clazz();
        error = env->GetMethodDeclaringClass(methodID, &clazz->_klazz);
        VWaveService::CheckException(error);
        MapJClazz(env, clazz->_klazz, clazz);
    }

    void MapJClazz(jvmtiEnv *env, jclass klazz, Clazz *clazz) {
        jvmtiError error;
        clazz->_klazz = klazz;
        error = env->GetClassSignature(klazz, &clazz->signature, &clazz->generic);
        VWaveService::CheckException(error);
        error = env->GetSourceFileName(klazz, &clazz->name);
        VWaveService::CheckException(error);
        error = env->GetClassModifiers(klazz, &clazz->access_flag);
        VWaveService::CheckException(error);
        error = env->IsInterface(klazz, &clazz->isInterface);
        VWaveService::CheckException(error);
    }

    void DeallocateMethod(jvmtiEnv *env, Method *method) {
        env->Deallocate(reinterpret_cast<unsigned char*>(method->name));
        env->Deallocate(reinterpret_cast<unsigned char*>(method->generic));
        env->Deallocate(reinterpret_cast<unsigned char*>(method->signature));
        env->Deallocate(reinterpret_cast<unsigned char*>(method));
    }

    ACCESS_FLAG ACC_PUBLIC = 1;
    ACCESS_FLAG ACC_PRIVATE = 1 << 1;
    ACCESS_FLAG ACC_PROTECTED = 1 << 3;
    ACCESS_FLAG ACC_FINAL = 1 << 4;
    ACCESS_FLAG ACC_SYNCHRONIZED = 1 << 5;
    ACCESS_FLAG ACC_BRIDGE = 1 << 6; //a bridge method that generated by compiler
    ACCESS_FLAG ACC_VARARGS = 1 << 7; //declared with a variable number of argument
    ACCESS_FLAG ACC_NATIVE = 1 << 8;
    ACCESS_FLAG ACC_ABSTRACT = 1 << 9;
    ACCESS_FLAG ACC_STRICT = 1 << 10;
    ACCESS_FLAG ACC_SYNTHETIC = 1 << 11; //declare syntheic; not present in the source code
}